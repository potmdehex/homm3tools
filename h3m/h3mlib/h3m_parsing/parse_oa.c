// Created by John Ã…kerblom 2014-11-22

#include "../h3mlib.h"
#include "parse_oa.h"
#include "parse_oa_meta_type.h"
#include "../safe_read.h"

#include "../h3m_object.h"

#include "../gen/def_bodies_array.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#ifdef _WIN32
#include <windows.h>            // DEBUG
#endif

#ifdef _MSC_VER
#pragma warning(disable:4996)   // M$ standard lib unsafe
#endif

// hash function generated by mph residing in src\gen\defs.c
extern int def_bodies_hash(const char *);

static int _add_to_oa_hash(struct H3MLIB_CTX *ctx, const char *def,
    int oa_index)
{
    struct META_OA_HASH_ENTRY *oa_hash_entry = NULL;
    int oa_body_index = 0;

    // It's ofc bad to do this downcasing all the time
    // TODO stop downcasing 24/7
    char def_lower[16] = { 0 };
    char *p = def_lower;

    strncpy(def_lower, def, sizeof(def_lower) - 1);
    for (; *p; ++p)
        *p = (char)tolower((int)*p);
    def = def_lower;

    if (0 > (oa_body_index = def_bodies_hash(def))) {
        return 1;
    } else if (oa_body_index >= sizeof(def_bodies_array) / sizeof(void *)) {
        return 1;
    } else if (0 != strcmp(def_bodies_array[oa_body_index], def)) {
        return 1;
    }

    oa_hash_entry = calloc(1, sizeof(*oa_hash_entry));
    oa_hash_entry->def = strdup(def);
    oa_hash_entry->oa_body_index = oa_body_index;
    oa_hash_entry->oa_index = oa_index;
    HASH_ADD_INT(ctx->meta.oa_hash, oa_body_index, oa_hash_entry);

    return 0;
}

int parse_oa(struct H3MLIB_CTX *ctx)
{
    struct H3M *p = &ctx->h3m;
    struct H3MLIB_META *meta = &ctx->meta;
    struct H3MLIB_PARSING *parsing = &ctx->parsing;
    int orig_off = parsing->offset;
    int saved_off = 0;
    int ret = 0;
    size_t n = 0;
    unsigned int i = 0;
    struct H3M_OA *oa = &p->oa;
    struct H3M_OA_ENTRY *oa_entry = NULL;
    struct META_OA_ENTRY *meta_entry = NULL;
    int is_custom = 0;

    SAFE_READ_SIZEOF(&oa->count, parsing)

    oa->entries = calloc(oa->count, sizeof(*(oa->entries)));
    meta->oa_entries = calloc(oa->count, sizeof(*(meta->oa_entries)));
    meta->oa_entries_count = oa->count;
    // The count is a 32-bit value, but somewhere above 32k objects doesn't seem legit
    SAFE_CHECK_N(oa->count, 32768)
    for (i = 0; i < oa->count; ++i) {
        oa_entry = &oa->entries[i];
        meta_entry = &meta->oa_entries[i];

        saved_off = parsing->offset;

        SAFE_READ_SIZEOF(&oa_entry->header.def_size, parsing)
        SAFE_ALLOC_N(oa_entry->header.def, oa_entry->header.def_size + 1,
            16 + 1)
        SAFE_READ_N(oa_entry->header.def, oa_entry->header.def_size,
            parsing)
        SAFE_READ_SIZEOF(&oa_entry->body, parsing)

        meta_entry->size = parsing->offset - saved_off;
        // Note that even the two ever-present OAs need to be set here.
        // AVLholg0.def is used in for instance Knight of Darkness.h3m (hole at 28,65)
        parse_oa_meta_type(oa_entry, &meta_entry->type, &is_custom,
            ctx->callbacks.cb_def, ctx->callbacks.cb_data);

        if (0xFF != meta_entry->type && 0 == is_custom) {
            _add_to_oa_hash(ctx, (const char *)oa_entry->header.def, i);
        }
    }

    if (NULL != ctx->callbacks.cb_parse) {
        n = parsing->offset - orig_off;
        ret = ctx->callbacks.cb_parse(orig_off, "oa", &parsing->raw[orig_off],
            n, ctx->callbacks.cb_data);
    }

    return ret;
}
